# -*- coding: utf-8 -*-
"""Untitled14.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1umxifo1stl5ABrf0Utdwj6w4uV4AMdVF
"""

from google.colab import files
uploaded = files.upload()

import zipfile
import os

zip_path = "CMAPSSData.zip"
extract_dir = "CMAPSS"

os.makedirs(extract_dir, exist_ok=True)

with zipfile.ZipFile(zip_path, "r") as zip_ref:
    zip_ref.extractall(extract_dir)

print("Extracted files:", os.listdir(extract_dir))

import pandas as pd
import numpy as np

train_path = "CMAPSS/train_FD001.txt"
df = pd.read_csv(train_path, sep=r"\s+", header=None)
df.columns = ["engine","cycle"] + \
             [f"op_setting_{i}" for i in range(1,4)] + \
             [f"sensor_{i}" for i in range(1,22)]
max_cycle = df.groupby("engine")["cycle"].transform("max")
df["RUL"] = max_cycle - df["cycle"]
df.head()

import numpy as np
#choosing sequence length according to dataset
sequence_length = 30
feature_cols = [col for col in df.columns if col not in ["engine", "cycle", "RUL"]]

X_sequences = []
y_sequences = []

for engine_id in df["engine"].unique():
    engine_data = df[df["engine"] == engine_id].reset_index(drop=True)

    for i in range(len(engine_data) - sequence_length):
        seq = engine_data.loc[i:i+sequence_length-1, feature_cols].values
        target = engine_data.loc[i+sequence_length-1, "RUL"]

        X_sequences.append(seq)
        y_sequences.append(target)

X_sequences = np.array(X_sequences)
y_sequences = np.array(y_sequences)

X_sequences.shape, y_sequences.shape

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

model = Sequential([
    LSTM(64, return_sequences=True, input_shape=(X_sequences.shape[1], X_sequences.shape[2])),
    Dropout(0.2),
    LSTM(32),
    Dropout(0.2),
    Dense(16, activation='relu'),
    Dense(1) ])
model.compile(
    optimizer='adam',
    loss='mse',
    metrics=['mae'])

model.summary()

history = model.fit(
    X_sequences, y_sequences,
    validation_split=0.2,
    epochs=10,
    batch_size=64,
    verbose=1)

import matplotlib.pyplot as plt

plt.plot(history.history["loss"], label="Train Loss", color='k')
plt.plot(history.history["val_loss"], label="Val Loss", color='blue')
plt.xlabel("Epoch")
plt.ylabel("MSE Loss")
plt.title("Training vs Validation Loss")
plt.legend()
plt.show()

preds = model.predict(X_sequences[:5])
list(zip(preds.flatten(), y_sequences[:5]))

#LOADING THE TEST DATA
test_path = "CMAPSS/test_FD001.txt"
rul_path  = "CMAPSS/RUL_FD001.txt"

test_df = pd.read_csv(test_path, sep=r"\s+", header=None)
test_df.columns = ["engine","cycle"] + \
                  [f"op_setting_{i}" for i in range(1,4)] + \
                  [f"sensor_{i}" for i in range(1,22)]

#Loading the true RUL value one per engine
true_rul = pd.read_csv(rul_path, sep="\s+", header=None)[0].values

test_df.head()

X_test = []

for eng in test_df["engine"].unique():
    temp = test_df[test_df["engine"] == eng].reset_index(drop=True)
    last_seq = temp.tail(sequence_length)   # last 30 cycles
    seq = last_seq[feature_cols].values

    # If engine has less than 30 cycles, pad at the top
    if seq.shape[0] < sequence_length:
        pad = np.zeros((sequence_length - seq.shape[0], seq.shape[1]))
        seq = np.vstack((pad, seq))

    X_test.append(seq)

X_test = np.array(X_test)
X_test.shape

y_pred = model.predict(X_test).flatten()
y_pred[:10]

from sklearn.metrics import mean_squared_error
import numpy as np

mse = mean_squared_error(true_rul, y_pred)
rmse = np.sqrt(mse)
rmse